<!DOCTYPE html>
<html>
<head>
  <title>WebGL2 Raytracer - Multiple Spheres</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
<canvas id="glCanvas"></canvas>
<script type="module">

// Setup
const canvas = document.getElementById("glCanvas");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const gl = canvas.getContext("webgl2");
if (!gl) throw new Error("WebGL2 not supported");

// Shaders
const vertexShaderSrc = `#version 300 es
precision mediump float;
in vec2 a_position;
out vec2 v_uv;
void main() {
  v_uv = a_position * 0.5 + 0.5;
  gl_Position = vec4(a_position, 0.0, 1.0);
}
`;

const fragmentShaderSrc = `#version 300 es
precision highp float;
out vec4 outColor;
in vec2 v_uv;

uniform vec3 u_cameraPos;
uniform vec3 u_cameraTarget;
uniform vec3 u_cameraUp;
uniform float u_fov;
uniform float u_aspect;

float sphereIntersect(vec3 ro, vec3 rd, vec3 center, float radius) {
  vec3 oc = ro - center;
  float b = dot(oc, rd);
  float c = dot(oc, oc) - radius * radius;
  float h = b * b - c;
  if (h < 0.0) return -1.0;
  return -b - sqrt(h);
}

void main() {
  vec3 forward = normalize(u_cameraTarget - u_cameraPos);
  vec3 right = normalize(cross(forward, u_cameraUp));
  vec3 up = cross(right, forward);

  vec2 uv = v_uv * 2.0 - 1.0;
  uv.x *= u_aspect;
  float focalLength = 1.0 / tan(u_fov * 0.5);

  vec3 ro = u_cameraPos;
  vec3 rd = normalize(forward * focalLength + right * uv.x + up * uv.y);

  // Define multiple spheres
  const int SPHERE_COUNT = 3;
  vec3 sphereCenters[SPHERE_COUNT];
  float sphereRadii[SPHERE_COUNT];

  sphereCenters[0] = vec3(0.0, 0.0, -2.0);
  sphereRadii[0] = 0.6;

  sphereCenters[1] = vec3(1.2, 0.5, -3.0);
  sphereRadii[1] = 0.4;

  sphereCenters[2] = vec3(-1.0, -0.3, -2.5);
  sphereRadii[2] = 0.5;

  // Find closest intersection
  float closestT = 1e20;
  int hitSphere = -1;

  for (int i = 0; i < SPHERE_COUNT; i++) {
    float t = sphereIntersect(ro, rd, sphereCenters[i], sphereRadii[i]);
    if (t > 0.0 && t < closestT) {
      closestT = t;
      hitSphere = i;
    }
  }

  // Shading
  if (hitSphere != -1) {
    vec3 hit = ro + closestT * rd;
    vec3 normal = normalize(hit - sphereCenters[hitSphere]);
    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
    float diffuse = max(dot(normal, lightDir), 0.0);

    // Different color per sphere
    vec3 colors[SPHERE_COUNT];
    colors[0] = vec3(0.0, 0.0, 1.0);  // Blue
    colors[1] = vec3(1.0, 0.0, 0.0);  // Red
    colors[2] = vec3(0.0, 1.0, 0.0);  // Green

    outColor = vec4(diffuse * colors[hitSphere], 1.0);
  } else {
    outColor = vec4(0.6, 0.8, 1.0, 1.0); // Background
  }
}
`;

// Shader helpers
function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    throw new Error(gl.getShaderInfoLog(shader));
  return shader;
}

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSrc);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSrc);

const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
if (!gl.getProgramParameter(program, gl.LINK_STATUS))
  throw new Error(gl.getProgramInfoLog(program));

// Quad
const quad = new Float32Array([
  -1, -1,  1, -1,
  -1,  1,  1,  1
]);

const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

const vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);

const loc = gl.getAttribLocation(program, "a_position");
gl.enableVertexAttribArray(loc);
gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

// Uniform locations
const u_cameraPosLoc = gl.getUniformLocation(program, "u_cameraPos");
const u_cameraTargetLoc = gl.getUniformLocation(program, "u_cameraTarget");
const u_cameraUpLoc = gl.getUniformLocation(program, "u_cameraUp");
const u_fovLoc = gl.getUniformLocation(program, "u_fov");
const u_aspectLoc = gl.getUniformLocation(program, "u_aspect");

// Camera parameters
const cameraPos = [0, 0, 1];
const cameraTarget = [0, 0, -2];
const cameraUp = [0, 1, 0];
const fov = Math.PI / 3; // 60 deg
const aspect = canvas.width / canvas.height;

// Render
function render() {
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.useProgram(program);
  gl.bindVertexArray(vao);

  gl.uniform3fv(u_cameraPosLoc, cameraPos);
  gl.uniform3fv(u_cameraTargetLoc, cameraTarget);
  gl.uniform3fv(u_cameraUpLoc, cameraUp);
  gl.uniform1f(u_fovLoc, fov);
  gl.uniform1f(u_aspectLoc, aspect);

  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

  requestAnimationFrame(render);
}
render();

</script>
</body>
</html>
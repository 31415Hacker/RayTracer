<!DOCTYPE html>
<html>
<head>
  <title>WebGL Raytracer - FPS Camera</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; color: white; font-family: sans-serif; }
    #fpsCounter { position: absolute; top: 10px; left: 10px; font-size: 20px; }
  </style>
</head>
<body>
<div id="fpsCounter">FPS: 0</div>
<canvas id="glCanvas"></canvas>
<script type="module">

// Setup
const canvas = document.getElementById("glCanvas");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const gl = canvas.getContext("webgl2");
if (!gl) throw new Error("WebGL2 not supported");

// Shaders
const vertexShaderSrc = `#version 300 es
precision mediump float;
in vec2 a_position;
out vec2 v_uv;
void main() {
  v_uv = a_position * 0.5 + 0.5;
  gl_Position = vec4(a_position, 0.0, 1.0);
}
`;

const fragmentShaderSrc = `#version 300 es
precision highp float;
out vec4 outColor;
in vec2 v_uv;

// Uniforms
uniform vec3 u_cameraPos;
uniform vec3 u_cameraTarget;
uniform vec3 u_cameraUp;
uniform float u_fov;
uniform float u_aspect;

// Sphere intersection
float sphereIntersect(vec3 ro, vec3 rd, vec3 center, float radius) {
  vec3 oc = ro - center;
  float b = dot(oc, rd);
  float c = dot(oc, oc) - radius * radius;
  float h = b * b - c;
  if (h < 0.0) return -1.0;
  return -b - sqrt(h);
}

// Main
void main() {
  vec3 forward = normalize(u_cameraTarget - u_cameraPos);
  vec3 right = normalize(cross(forward, u_cameraUp));
  vec3 up = cross(right, forward);

  vec2 uv = v_uv * 2.0 - 1.0;
  uv.x *= u_aspect;
  float focalLength = 1.0 / tan(u_fov * 0.5);

  vec3 ro = u_cameraPos;
  vec3 rd = normalize(forward * focalLength + right * uv.x + up * uv.y);

  vec3 sphereCenter = vec3(0.0, 0.0, -2.0);
  float t = sphereIntersect(ro, rd, sphereCenter, 0.6);

  if (t > 0.0) {
    vec3 hit = ro + t * rd;
    vec3 normal = normalize(hit - sphereCenter);
    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
    float diffuse = max(dot(normal, lightDir), 0.0);
    vec3 albedo = vec3(0.0, 0.0, 1.0);
    outColor = vec4(diffuse * albedo, 1.0);
  } else {
    outColor = vec4(0.6, 0.8, 1.0, 1.0);
  }
}
`;

// Shader helpers
function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    throw new Error(gl.getShaderInfoLog(shader));
  return shader;
}

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSrc);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSrc);

const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
if (!gl.getProgramParameter(program, gl.LINK_STATUS))
  throw new Error(gl.getProgramInfoLog(program));

// Quad
const quad = new Float32Array([
  -1, -1,  1, -1,
  -1,  1,  1,  1
]);

const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

const vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);

const loc = gl.getAttribLocation(program, "a_position");
gl.enableVertexAttribArray(loc);
gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

// Uniform locations
const u_cameraPosLoc = gl.getUniformLocation(program, "u_cameraPos");
const u_cameraTargetLoc = gl.getUniformLocation(program, "u_cameraTarget");
const u_cameraUpLoc = gl.getUniformLocation(program, "u_cameraUp");
const u_fovLoc = gl.getUniformLocation(program, "u_fov");
const u_aspectLoc = gl.getUniformLocation(program, "u_aspect");

// FPS Camera state
let cameraPos = [0, 0, 1];
let yaw = 0;     // rotation around Y
let pitch = 0;   // rotation around X
const cameraUp = [0, 1, 0];
const fov = Math.PI / 3;
const aspect = canvas.width / canvas.height;

let keys = [];
window.addEventListener("keydown", e => {
  if (!keys.includes(e.key)) keys.push(e.key);
});
window.addEventListener("keyup", e => {
  const index = keys.indexOf(e.key);
  if (index !== -1) keys.splice(index, 1);
});

// Mouse look
canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
canvas.onclick = () => canvas.requestPointerLock();

document.addEventListener("pointerlockchange", () => {
  if (document.pointerLockElement === canvas) {
    document.addEventListener("mousemove", onMouseMove, false);
  } else {
    document.removeEventListener("mousemove", onMouseMove, false);
  }
});

function onMouseMove(e) {
  const sensitivity = 0.002;
  yaw += e.movementX * sensitivity;
  pitch -= e.movementY * sensitivity;
  pitch = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, pitch));
}

// FPS Counter
const fpsCounter = document.getElementById("fpsCounter");
let lastFrameTime = performance.now();
let frameCount = 0;
let lastFpsUpdate = performance.now();

function render() {
  // Update camera target
  const cosPitch = Math.cos(pitch);
  const sinPitch = Math.sin(pitch);
  const cosYaw = Math.cos(yaw);
  const sinYaw = Math.sin(yaw);

  const forward = [
    cosPitch * sinYaw,
    sinPitch,
    cosPitch * cosYaw * -1
  ];

  const right = [cosYaw, 0, sinYaw];
  const speed = 0.05;

  // Move camera
  if (keys.includes("w") || keys.includes("W")) {
    cameraPos[0] += forward[0] * speed;
    cameraPos[1] += forward[1] * speed;
    cameraPos[2] += forward[2] * speed;
  }
  if (keys.includes("s") || keys.includes("S")) {
    cameraPos[0] -= forward[0] * speed;
    cameraPos[1] -= forward[1] * speed;
    cameraPos[2] -= forward[2] * speed;
  }
  if (keys.includes("a") || keys.includes("A")) {
    cameraPos[0] -= right[0] * speed;
    cameraPos[2] -= right[2] * speed;
  }
  if (keys.includes("d") || keys.includes("D")) {
    cameraPos[0] += right[0] * speed;
    cameraPos[2] += right[2] * speed;
  }

  const cameraTarget = [
    cameraPos[0] + forward[0],
    cameraPos[1] + forward[1],
    cameraPos[2] + forward[2]
  ];

  // Render
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.useProgram(program);
  gl.bindVertexArray(vao);

  gl.uniform3fv(u_cameraPosLoc, cameraPos);
  gl.uniform3fv(u_cameraTargetLoc, cameraTarget);
  gl.uniform3fv(u_cameraUpLoc, cameraUp);
  gl.uniform1f(u_fovLoc, fov);
  gl.uniform1f(u_aspectLoc, aspect);

  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

  // FPS counting
  const now = performance.now();
  frameCount++;
  if (now - lastFpsUpdate >= 500) {
    const fps = (frameCount / (now - lastFpsUpdate)) * 1000;
    fpsCounter.textContent = `FPS: ${fps.toFixed(1)}`;
    lastFpsUpdate = now;
    frameCount = 0;
  }

  requestAnimationFrame(render);
}
render();

</script>
</body>
</html>